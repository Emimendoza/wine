--- dlls/inseng/inseng_main.c
+++ dlls/inseng/inseng_main.c
@@ -29,17 +30,68 @@
 #include "winuser.h"
 #include "ole2.h"
 #include "rpcproxy.h"
+#include "urlmon.h"
+#include "shlwapi.h"
 #include "initguid.h"
 #include "inseng.h"
 
+#include "inseng_private.h"
+
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(inseng);
 
+enum thread_operation
+{
+    OP_DOWNLOAD,
+    OP_INSTALL
+};
+
+struct thread_info
+{
+    DWORD operation;
+    DWORD jobflags;
+    IEnumCifComponents *enum_comp;
+
+    DWORD download_size;
+    DWORD install_size;
+
+    DWORD downloaded_kb;
+    ULONGLONG download_start;
+};
+
 struct InstallEngine {
     IInstallEngine2 IInstallEngine2_iface;
+    IInstallEngineTiming IInstallEngineTiming_iface;
     LONG ref;
+
+    IInstallEngineCallback *callback;
+    char *baseurl;
+    char *downloaddir;
+    ICifFile *icif;
+    DWORD status;
+
+    /* used for the installation thread */
+    struct thread_info thread;
+};
+
+struct downloadcb
+{
+    IBindStatusCallback IBindStatusCallback_iface;
+    LONG ref;
+
+    WCHAR *file_name;
+    WCHAR *cache_file;
+
+    char *id;
+    char *display;
+
+    DWORD dl_size;
+    DWORD dl_previous_kb;
+
+    InstallEngine *engine;
+    HANDLE event_done;
+    HRESULT hr;
 };
 
 static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
@@ -334,181 +633,726 @@ static ULONG WINAPI InstallEngine_Release(IInstallEngine2 *iface)
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
-    if(!ref)
+    if (!ref)
+    {
+        if (This->icif)
+            ICifFile_Release(This->icif);
+
+        heap_free(This->baseurl);
+        heap_free(This->downloaddir);
         heap_free(This);
+    }
 
     return ref;
 }
 
+static void set_status(InstallEngine *This, DWORD status)
+{
+    This->status = status;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, status, 0);
+}
+
+static HRESULT calc_sizes(IEnumCifComponents *enum_comp, DWORD operation, DWORD *size_download, DWORD *size_install)
+{
+    ICifComponent *comp;
+    DWORD download = 0;
+    DWORD install = 0;
+    HRESULT hr;
+
+    /* FIXME: what about inactive dependencies and how does
+     * INSTALLOPTIONS_FORCEDEPENDENCIES play into this ?*/
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) == S_FALSE)
+            download = ICifComponent_GetDownloadSize(comp);
+        /*
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) == S_FALSE)
+            install = ICifComponent_GetInstalledSize(comp);
+        */
+    }
+
+    *size_download = download;
+    *size_install = install;
+
+    return S_OK;
+}
+
+static HRESULT get_next_component(IEnumCifComponents *enum_comp, DWORD operation, ICifComponent **ret_comp)
+{
+    ICifComponent *comp;
+    HRESULT hr;
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) != S_FALSE)
+            continue;
+
+        *ret_comp = comp;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT get_url(ICifComponent *comp, int index, char **url, DWORD *flags)
+{
+    char *url_temp = NULL;
+    int size = MAX_PATH / 2;
+    HRESULT hr;
+
+    /* FIXME: should we add an internal get function to prevent this ugly code ? */
+
+    /* check if there is an url with such an index */
+    hr = ICifComponent_GetUrl(comp, index, NULL, 0, flags);
+    if (FAILED(hr))
+    {
+        *url = NULL;
+        *flags = 0;
+        return S_OK;
+    }
+
+    do
+    {
+        size *= 2;
+        heap_free(url_temp);
+        url_temp = heap_alloc(size);
+        if (!url_temp) return E_OUTOFMEMORY;
+
+        hr = ICifComponent_GetUrl(comp, index, url_temp, size, flags);
+        if (FAILED(hr))
+        {
+            heap_free(url_temp);
+            return hr;
+        }
+    }
+    while (strlen(url_temp) == size-1);
+
+    *url = url_temp;
+    return S_OK;
+}
+
+static char *combine_url(char *baseurl, char *url)
+{
+    int len_base = strlen(baseurl);
+    int len_url = strlen(url);
+    char *combined;
+
+    combined = heap_alloc(len_base + len_url + 2);
+    if (!combined) return NULL;
+
+    strcpy(combined, baseurl);
+    if (len_base && combined[len_base-1] != '/')
+        strcat(combined, "/");
+    strcat(combined, url);
+
+    return combined;
+}
+
+static HRESULT generate_moniker(char *baseurl, char *url, DWORD flags, IMoniker **moniker)
+{
+    WCHAR *urlW;
+    HRESULT hr;
+
+    if (flags & URLF_RELATIVEURL)
+    {
+        char *combined;
+        if (!baseurl)
+            return E_FAIL;
+
+        combined = combine_url(baseurl, url);
+        if (!combined) return E_OUTOFMEMORY;
+
+        urlW = strAtoW(combined);
+        heap_free(combined);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+    else
+    {
+        urlW = strAtoW(url);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+
+    hr = CreateURLMoniker(NULL, urlW, moniker);
+    heap_free(urlW);
+    return hr;
+}
+
+static char *merge_path(char *path1, char *path2)
+{
+    int len = strlen(path1) + strlen(path2) + 2;
+    char *combined = heap_alloc(len);
+
+    if (!combined) return NULL;
+    strcpy(combined, path1);
+    strcat(combined, "\\");
+    strcat(combined, path2);
+
+    return combined;
+}
+
+static HRESULT download_url(InstallEngine *This, char *id, char *display, char *url, DWORD flags, DWORD dl_size)
+{
+    struct downloadcb *callback = NULL;
+    char *filename    = NULL;
+    IUnknown *unk     = NULL;
+    IMoniker *mon     = NULL;
+    IBindCtx *bindctx = NULL;
+    HANDLE event      = NULL;
+    HRESULT hr;
+
+    if (!This->downloaddir)
+    {
+        WARN("No download directory set\n");
+        return E_FAIL;
+    }
+
+    hr = generate_moniker(This->baseurl, url, flags, &mon);
+    if (FAILED(hr))
+    {
+        FIXME("Failed to create moniker\n");
+        return hr;
+    }
+
+    event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!event)
+    {
+        IMoniker_Release(mon);
+        return E_FAIL;
+    }
+
+    filename = strrchr(url, '/');
+    if (!filename) filename = url;
+
+    filename = merge_path(This->downloaddir, filename);
+    if (!filename)
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+
+    hr = downloadcb_create(This, event, filename, id, display, dl_size, &callback);
+    if (FAILED(hr)) goto error;
+
+    hr = CreateAsyncBindCtx(0, &callback->IBindStatusCallback_iface, NULL, &bindctx);
+    if(FAILED(hr)) goto error;
+
+    hr = IMoniker_BindToStorage(mon, bindctx, NULL, &IID_IUnknown, (void**)&unk);
+    if (FAILED(hr)) goto error;
+    if (unk) IUnknown_Release(unk);
+
+    heap_free(filename);
+    IMoniker_Release(mon);
+    IBindCtx_Release(bindctx);
+
+    WaitForSingleObject(event, INFINITE);
+    hr = callback->hr;
+
+    CloseHandle(event);
+    IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    return hr;
+
+error:
+    if (mon) IMoniker_Release(mon);
+    if (event) CloseHandle(event);
+    if (callback) IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    if (bindctx) IBindCtx_Release(bindctx);
+    if (filename) heap_free(filename);
+    return hr;
+}
+
+static HRESULT process_component_dependencies(InstallEngine *This, ICifComponent *comp)
+{
+    char id[MAX_ID_LENGTH+1], type;
+    DWORD ver, build;
+    HRESULT hr;
+    int i;
+
+    for (i = 0;; i++)
+    {
+        hr = ICifComponent_GetDependency(comp, i, id, sizeof(id), &type, &ver, &build);
+        if (SUCCEEDED(hr))
+            FIXME("Can't handle dependencies yet: %s\n", debugstr_a(id));
+        else
+            break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT process_component(InstallEngine *This, ICifComponent *comp)
+{
+    DWORD size_dl, size_install, phase;
+    char display[MAX_DISPLAYNAME_LENGTH+1];
+    char id[MAX_ID_LENGTH+1];
+    HRESULT hr;
+    int i;
+
+    hr = ICifComponent_GetID(comp, id, sizeof(id));
+    if (FAILED(hr)) return hr;
+
+    TRACE("processing component %s\n", debugstr_a(id));
+
+    hr = ICifComponent_GetDescription(comp, display, sizeof(display));
+    if (FAILED(hr)) return hr;
+
+    size_dl      = (This->thread.operation == OP_DOWNLOAD) ? ICifComponent_GetDownloadSize(comp) : 0;
+    size_install = 0; /* (This->thread.operation == OP_INSTALL) ? ICifComponent_GetInstalledSize(comp) : 0; */
+
+    if (This->callback)
+    {
+        IInstallEngineCallback_OnStartComponent(This->callback, id, size_dl, size_install, display);
+        IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_INITIALIZING, display, NULL, 0, 0);
+        phase = INSTALLSTATUS_INITIALIZING;
+    }
+
+    hr = process_component_dependencies(This, comp);
+    if (FAILED(hr)) return hr;
+
+    if (This->thread.operation == OP_DOWNLOAD)
+    {
+        for (i = 0;; i++)
+        {
+            DWORD flags;
+            char *url;
+
+            phase = INSTALLSTATUS_DOWNLOADING;
+
+            hr = get_url(comp, i, &url, &flags);
+            if (FAILED(hr)) goto done;
+            if (!url) break;
+
+            TRACE("processing url %s\n", debugstr_a(url));
+
+            hr = download_url(This, id, display, url, flags, size_dl);
+            heap_free(url);
+            if (FAILED(hr))
+            {
+                DWORD retry = 0;
+
+                if (This->callback)
+                    IInstallEngineCallback_OnEngineProblem(This->callback, ENGINEPROBLEM_DOWNLOADFAIL, &retry);
+                if (!retry) goto done;
+
+                i--;
+                continue;
+            }
+
+            phase = INSTALLSTATUS_CHECKINGTRUST;
+            /* FIXME: check trust */
+            IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_CHECKINGTRUST, display, NULL, 0, 0);
+        }
+
+        component_set_downloaded(comp, TRUE);
+        phase = INSTALLSTATUS_DOWNLOADFINISHED;
+    }
+    else
+        FIXME("Installation not yet implemented\n");
+
+done:
+    IInstallEngineCallback_OnStopComponent(This->callback, id, hr, phase, display, 0);
+    return hr;
+}
+
+DWORD WINAPI thread_installation(LPVOID param)
+{
+    InstallEngine *This = param;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    if (This->callback)
+        IInstallEngineCallback_OnStartInstall(This->callback, This->thread.download_size, This->thread.install_size);
+
+    for (;;)
+    {
+        hr = get_next_component(This->thread.enum_comp, This->thread.operation, &comp);
+        if (FAILED(hr)) break;
+        if (hr == S_FALSE)
+        {
+            hr = S_OK;
+            break;
+        }
+
+        hr = process_component(This, comp);
+        if (FAILED(hr)) break;
+    }
+
+    if (This->callback)
+        IInstallEngineCallback_OnStopInstall(This->callback, hr, NULL, 0);
+
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    IInstallEngine2_Release(&This->IInstallEngine2_iface);
+
+    set_status(This, ENGINESTATUS_READY);
+    return 0;
+}
+
+static HRESULT start_installation(InstallEngine *This, DWORD operation, DWORD jobflags)
+{
+    HANDLE thread;
+    HRESULT hr;
+
+    This->thread.operation = operation;
+    This->thread.jobflags  = jobflags;
+    This->thread.downloaded_kb = 0;
+    This->thread.download_start = 0;
+
+    /* Windows sends the OnStartInstall event from a different thread,
+     * but OnStartInstall already contains the required download and install size.
+     * The only way to signal an error from the thread is to send an OnStopComponent /
+     * OnStopInstall signal which can only occur after OnStartInstall. We need to
+     * precompute the sizes here to be able inform the application about errors while
+     * calculating the required sizes. */
+
+    hr = ICifFile_EnumComponents(This->icif, &This->thread.enum_comp, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    hr = calc_sizes(This->thread.enum_comp, operation, &This->thread.download_size, &This->thread.install_size);
+    if (FAILED(hr)) goto error;
+
+    IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+
+    thread = CreateThread(NULL, 0, thread_installation, This, 0, NULL);
+    if (!thread)
+    {
+        IInstallEngine2_Release(&This->IInstallEngine2_iface);
+        hr = E_FAIL;
+        goto error;
+    }
+
+    CloseHandle(thread);
+    return S_OK;
+
+error:
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    return hr;
+}
+
 static HRESULT WINAPI InstallEngine_GetEngineStatus(IInstallEngine2 *iface, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, status);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, status);
+
+    if (!status)
+        return E_FAIL;
+
+    *status = This->status;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetCifFile(IInstallEngine2 *iface, const char *cab_name, const char *cif_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_DownloadComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%#lx)\n", This, flags);
+
+    /* The interface is not really threadsafe on windows, but we can at least prevent multiple installations */
+    if (InterlockedCompareExchange((LONG *)&This->status, ENGINESTATUS_INSTALLING, ENGINESTATUS_READY) != ENGINESTATUS_READY)
+        return E_FAIL;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, ENGINESTATUS_INSTALLING, 0);
+
+    return start_installation(This, OP_DOWNLOAD, flags);
 }
 
 static HRESULT WINAPI InstallEngine_InstallComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumInstallIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
+
+    FIXME("(%p)->(%u %p): stub\n", This, index, id);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumDownloadIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
-    return E_NOTIMPL;
+    IEnumCifComponents *enum_components;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%u %p)\n", This, index, id);
+
+    if (!This->icif || !id)
+        return E_FAIL;
+
+    hr = ICifFile_EnumComponents(This->icif, &enum_components, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    for (;;)
+    {
+        hr = IEnumCifComponents_Next(enum_components, &comp);
+        if (FAILED(hr)) goto done;
+
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        if (ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+
+        if (index == 0)
+        {
+            char *id_src = component_get_id(comp);
+            *id = CoTaskMemAlloc(strlen(id_src) + 1);
+
+            if (*id)
+                strcpy(*id, id_src);
+            else
+                hr = E_OUTOFMEMORY;
+            goto done;
+        }
+
+        index--;
+    }
+
+done:
+    IEnumCifComponents_Release(enum_components);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_IsComponentInstalled(IInstallEngine2 *iface, const char *id, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), status);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), status);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_RegisterInstallEngineCallback(IInstallEngine2 *iface, IInstallEngineCallback *callback)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, callback);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, callback);
+
+    This->callback = callback;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_UnregisterInstallEngineCallback(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
+
+    TRACE("(%p)\n", This);
+
+    This->callback = NULL;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetAction(IInstallEngine2 *iface, const char *id, DWORD action, DWORD priority)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %ld %ld)\n", This, debugstr_a(id), action, priority);
-    return E_NOTIMPL;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %lu %lu)\n", This, debugstr_a(id), action, priority);
+
+    if (!This->icif)
+        return E_FAIL; /* FIXME: check error code */
+
+    hr = ICifFile_FindComponent(This->icif, id, &comp);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetInstallQueueState(comp, action);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetCurrentPriority(comp, priority);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_GetSizes(IInstallEngine2 *iface, const char *id, COMPONENT_SIZES *sizes)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), sizes);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), sizes);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_LaunchExtraCommand(IInstallEngine2 *iface, const char *inf_name, const char *section)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(inf_name), debugstr_a(section));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(inf_name), debugstr_a(section));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_GetDisplayName(IInstallEngine2 *iface, const char *id, const char *name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(id), debugstr_a(name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(id), debugstr_a(name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetBaseUrl(IInstallEngine2 *iface, const char *base_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(base_name));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(base_name));
+
+    if (This->baseurl)
+        heap_free(This->baseurl);
+
+    This->baseurl = strdupA(base_name);
+    return This->baseurl ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetDownloadDir(IInstallEngine2 *iface, const char *download_dir)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(download_dir));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(download_dir));
+
+    if (This->downloaddir)
+        heap_free(This->downloaddir);
+
+    This->downloaddir = strdupA(download_dir);
+    return This->downloaddir ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallDrive(IInstallEngine2 *iface, char drive)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%c)\n", This, drive);
+
+    FIXME("(%p)->(%c): stub\n", This, drive);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallOptions(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetHWND(IInstallEngine2 *iface, HWND hwnd)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, hwnd);
+
+    FIXME("(%p)->(%p): stub\n", This, hwnd);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetIStream(IInstallEngine2 *iface, IStream *stream)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, stream);
+
+    FIXME("(%p)->(%p): stub\n", This, stream);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Abort(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Suspend(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Resume(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine2_SetLocalCif(IInstallEngine2 *iface, const char *cif)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(cif));
-    return E_NOTIMPL;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(cif));
+
+    if (This->icif)
+        ICifFile_Release(This->icif);
+
+    set_status(This, ENGINESTATUS_LOADING);
+
+    hr = GetICifFileFromFile(&This->icif, cif);
+    if (SUCCEEDED(hr))
+        set_status(This, ENGINESTATUS_READY);
+    else
+    {
+        This->icif = NULL;
+        set_status(This, ENGINESTATUS_NOTREADY);
+    }
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine2_GetICifFile(IInstallEngine2 *iface, ICifFile **cif_file)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, cif_file);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, cif_file);
+
+    if (!This->icif || !cif_file)
+        return E_FAIL;
+
+    ICifFile_AddRef(This->icif);
+    *cif_file = This->icif;
+    return S_OK;
 }
 
-static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
+static const IInstallEngine2Vtbl InstallEngine2Vtbl =
+{
     InstallEngine_QueryInterface,
     InstallEngine_AddRef,
     InstallEngine_Release,
@@ -646,12 +1554,14 @@ static HRESULT WINAPI InstallEngineCF_CreateInstance(IClassFactory *iface, IUnkn
 
     TRACE("(%p %s %p)\n", outer, debugstr_guid(riid), ppv);
 
-    engine = heap_alloc(sizeof(*engine));
+    engine = heap_alloc_zero(sizeof(*engine));
     if(!engine)
         return E_OUTOFMEMORY;
 
     engine->IInstallEngine2_iface.lpVtbl = &InstallEngine2Vtbl;
+    engine->IInstallEngineTiming_iface.lpVtbl = &InstallEngineTimingVtbl;
     engine->ref = 1;
+    engine->status = ENGINESTATUS_NOTREADY;
 
     hres = IInstallEngine2_QueryInterface(&engine->IInstallEngine2_iface, riid, ppv);
     IInstallEngine2_Release(&engine->IInstallEngine2_iface);
